using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Configuration;

namespace GenerateElunaEnums
{
   static class Program
   {
      static void Main(string[] args)
      {
         string hooksHeader = GetHooksHeader();
         List<HookEnum> parsedEnums = ParseHooksHeader(hooksHeader);
         /*
         foreach (HookEnum hookEnum in parsedEnums)
         {
            Console.WriteLine($"{hookEnum}{System.Environment.NewLine}");
         }
         Console.ReadKey();
         */
         GenerateLuaFile(parsedEnums);
      }

      private static void GenerateLuaFile(List<HookEnum> parsedEnums)
      {
         string outputPath = ConfigurationManager.AppSettings["OutputPath"];
         using (System.IO.StreamWriter file = new System.IO.StreamWriter($"{outputPath}\\Constants.lua"))
         {
            file.WriteLine(@"-- Generated by GenerateElunaEnums on " + System.DateTime.Now);
            // Add the declaration for readOnlyTables
            string readOnlyTable = @"function readOnlyTable(table)"                                   + Environment.NewLine +
                                   @"  return setmetatable({}, {"                                     + Environment.NewLine +
                                   @"    __index = table,"                                            + Environment.NewLine +
                                   @"    __newindex = function(table, key, value)"                    + Environment.NewLine +
                                   @"                   error(""Attempt to modify read-only table"")" + Environment.NewLine +
                                   @"                 end,"                                           + Environment.NewLine +
                                   @"    __metatable = false"                                         + Environment.NewLine +
                                   @"  }); "                                                          + Environment.NewLine +
                                   @"end"                                                             + Environment.NewLine + Environment.NewLine;
            file.Write(readOnlyTable);
            foreach (HookEnum hookEnum in parsedEnums)
            {
               file.WriteLine($"{hookEnum}{System.Environment.NewLine}");
            }
         }
      }

      private static string GetHooksHeader()
      {
         string html = string.Empty;
         const string url = @"https://github.com/ElunaLuaEngine/Eluna/raw/master/Hooks.h";

         ServicePointManager.Expect100Continue = true;
         ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

         HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
         request.AutomaticDecompression = DecompressionMethods.GZip;

         using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
         using (Stream stream = response.GetResponseStream())
         using (StreamReader reader = new StreamReader(stream))
         {
            html = reader.ReadToEnd();
         }
         return html;
      }

      private static List<HookEnum> ParseHooksHeader(string hooksHeader)
      {
         string luaString = String.Empty;
         Regex enumNameRegex = new Regex(@"enum (\w+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
         Regex enumValueRegex = new Regex(@"(\w+)\s*={0,1}\s*(\d*),{0,1}\s*\/{0,2}\s*(.*)$", RegexOptions.Compiled | RegexOptions.IgnoreCase);

         List<HookEnum> enums = new List<HookEnum>();
         HookEnum currentEnum = new HookEnum();
         using (StringReader reader = new StringReader(hooksHeader))
         {
            string line;
            int previousId = -1;
            while ((line = reader.ReadLine()) != null)
            {
               // If we don't currently have an enum to parse, try to find one
               if (currentEnum.name == null)
               { 
                  Match match = enumNameRegex.Match(line);
                  if (match.Success) currentEnum.name = match.Groups[1].Value;
               }
               // If we do have an enum to parse, go into parsing mode.
               else
               {
                  // Don't need the first line or commented out lines
                  if (line.Contains(@"{") || line.Trim().StartsWith(@"//")) continue;
                  else if (line.Contains(@"}"))
                  {
                     // We've found the end of the enum.
                     enums.Add(currentEnum);
                     currentEnum = new HookEnum();
                     previousId = -1;
                     continue;
                  }

                  // Try to get the enum values.
                  Match match = enumValueRegex.Match(line);
                  if (match.Success)
                  {
                     int id;
                     bool idIsEmpty = String.IsNullOrWhiteSpace(match.Groups[2].Value);
                     if      (idIsEmpty && previousId == -1) id = 0;
                     else if (idIsEmpty)                     id = previousId + 1;
                     else                                    id = Int32.Parse(match.Groups[2].Value);

                     string name = match.Groups[1].Value;
                     string comment = match.Groups[3].Value;
                     Hook newHook = new Hook(name, id, comment);
                     currentEnum.values.Add(newHook);

                     // Save off the previous ID in case the next value in the enum
                     // doens't have an ID specified.
                     previousId = id;
                  }
               }
            }
         }
         return enums;
      }
   }

   class HookEnum
   {
      public string name;
      public List<Hook> values;

      public HookEnum()
      {
         name = null;
         values = new List<Hook>();
      }

      public override string ToString()
      {
         StringBuilder sb = new StringBuilder();
         sb.Append($"{name} = readOnlyTable {{{System.Environment.NewLine}");
         foreach(Hook value in values)
         {
            sb.Append($"  {value}{System.Environment.NewLine}");
         }
         sb.Append(@"}");
         return sb.ToString();
      }
   }

   class Hook
   {
      public string name;
      public int id;
      public string comment;

      public Hook(string Name, int Id, string Comment)
      {
         name = Name;
         id = Id;
         comment = Comment;
      }
 
      public override string ToString()
      {
         StringBuilder sb = new StringBuilder();
         sb.Append($"{name} = {id},");
         if (!String.IsNullOrWhiteSpace(comment)) sb.Append($" -- {comment}");
         return sb.ToString();
      }
   }
}
